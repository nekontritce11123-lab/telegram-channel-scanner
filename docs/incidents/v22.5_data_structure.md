# КРИТИЧЕСКИЕ ОШИБКИ v22.5 (2026-01-16) — НЕ ПОВТОРЯТЬ!

## 1. parse_category_response() возвращает строку, не tuple
**Проблема:** Callback `_on_category_ready` в crawler.py пытался распаковать tuple:
```python
primary, secondary, percent = parse_category_response(category)  # ❌ TypeError!
```
**Причина:** В v15.0 classifier.py изменился на single-label, теперь возвращает строку.
**Решение:**
```python
def _on_category_ready(self, channel_id: int, category: str):
    # v15.0: category - уже готовая строка (CRYPTO, TECH, и т.д.)
    self.db.set_category(username, category, None, 100)
```
**Правило:** При изменении возвращаемого типа функции — ОБНОВИТЬ ВСЕ вызывающие места.

## 2. reactions_enabled = (total_reactions > 0) — НЕПРАВИЛЬНО
**Проблема:** Каналы с включёнными реакциями, но 0 реакций показывали "откл."
**Причина:** Старая проверка в scorer.py:
```python
total_reactions = sum(get_message_reactions_count(m) for m in messages)
reactions_enabled = total_reactions > 0  # ❌ 0 реакций = выключены?
```
**Правильная логика:**
- Реакции ОТКЛЮЧЕНЫ: ни один пост не имеет атрибута `reactions`
- Реакции ВКЛЮЧЕНЫ (0 реакций): атрибут `reactions` есть, но пустой/None
**Решение:** Новая функция `check_reactions_enabled()` в metrics.py:
```python
def check_reactions_enabled(messages: list) -> bool:
    # Если есть хоть одна реакция - точно включены
    total = sum(get_message_reactions_count(m) for m in messages)
    if total > 0:
        return True
    # Проверяем есть ли атрибут reactions хоть у одного поста
    for m in messages:
        if hasattr(m, 'reactions') and m.reactions is not None:
            return True
    return False
```

## 3. Flags не сохраняются в БД
**Проблема:** `reactions_enabled`, `comments_enabled` не попадали в базу → UI показывал "откл." для всех.
**Причина:** Crawler передавал только `breakdown` dict без `flags`:
```python
self.db.mark_done(..., breakdown=score_result.get('breakdown'))  # ❌ Нет flags!
```
**Решение v22.5:** Сливаем flags в breakdown перед сохранением:
```python
breakdown = score_result.get('breakdown', {})
flags = score_result.get('flags', {})
if breakdown and flags:
    breakdown['reactions_enabled'] = flags.get('reactions_enabled', True)
    breakdown['comments_enabled'] = flags.get('comments_enabled', True)
    breakdown['floating_weights'] = flags.get('floating_weights', False)
```

## 4. Структура breakdown_json: nested vs flat
**Проблема:** Ручное обновление БД сохраняло flat структуру, backend ожидал nested.
**Flat (НЕПРАВИЛЬНО):**
```json
{"cv_views": {...}, "reach": {...}, "reactions_enabled": true}
```
**Nested (ПРАВИЛЬНО):**
```json
{
  "breakdown": {"cv_views": {...}, "reach": {...}, "reactions_enabled": true},
  "categories": {"quality": {...}, "engagement": {...}, "reputation": {...}}
}
```
**Правило:** ВСЕГДА проверять структуру данных в БД и что ожидает код:
```python
# database.py line 267-270
breakdown_json = json.dumps({
    'breakdown': breakdown,
    'categories': categories
}, ensure_ascii=False)
```

## 5. Не останавливать краулер перед изменением кода
**Проблема:** Внёс исправления в scorer.py пока краулер работал → изменения не применились к текущему сканированию.
**Причина:** Python загружает модули в память при старте. Изменения файла не влияют на запущенный процесс.
**Правило:**
1. ОСТАНОВИТЬ краулер (Ctrl+C или KillShell)
2. Внести изменения в код
3. Запустить краулер заново
4. Пересканировать каналы которые были отсканированы со старым кодом
